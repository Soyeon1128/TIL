## call 과 apply
 > ### 함수가 this본문 에서 키워드를 사용하는 경우 모든 함수가 상속 하는 call또는을 사용하여 해당 값을 호출의 특정 개체에 바인딩 할 수 있습니다 .applyFunction.prototype
```javascript
  function add(c, d) {
    return this.a + this.b + c + d;
  }

  var o = {a: 1, b: 3};  
  add.call(o, 5, 7);  // this === o
  // this.a + this.b + c + d -> a + b + c + d
  // 1 + 3 + 5 + 7 -> 16

  add.apply(o, [10, 20]);
  // this.a + this.b + c + d -> a + b + c + d
  // 1 + 3 + 10 + 20 -> 34
```
 + call apply, 의 차이는 두번째 인자를 배열로 받느냐 콤마로 받느냐 차이 입니다.
 ## The bind method
 > ### ECMAScript 5가 도입 Function.prototype.bind되었습니다. 호출 f.bind(someObject)은 본문과 범위가 같은 새 함수를 만듭니다. 그러나 원래 this 함수 에서 발생하는 경우 새 함수 bind에서 함수의 사용 방법에 관계없이 첫 번째 인수에 영구적으로 바인딩 됩니다.

```javascript
  function f() {
    return this.a;
  }

  var g = f.bind({a: 'azerty'});
  console.log(g()); // azerty
  // this.a = azerty

  var h = g.bind({a: 'yoo'}); // bind only works once!
  // hard binding 이라서 attach는 한번만 가능하다.
  console.log(h()); // azerty

  var o = {a: 37, f: f, g: g, h: h};
  console.log(o.f(), o.g(), o.h()); 
```
 +  a:37, f:function f() {
    return this.a;
  }, g: f.bind({a: 'azerty'}), h: g.bind({a: 'yoo'})
+ 순서로 해석 되어지므로  o.f() -> 37, o.g() -> azerty, o.h() -> azerty
